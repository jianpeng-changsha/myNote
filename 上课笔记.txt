


红黑树是一个特殊的二叉搜索树，红黑树上一部分是黑色，一部分是红色，叶节点是黑色的，没有连续的红色节点，红色节点的孩子和父亲都是黑色，对每个节点
2-3-4树变成红黑树：单key节点变成黑色节点，把双key节点变成一黑一红，3key节点变成中间红两边黑，或者中间黑两边红（常用）
llrb_tree 左倾红黑树：拆除2-3-4树的时候红色在左边，要求一个节点所有节点在红黑树中，如果只有几个孩子是红色，那么这个红色的孩子应该是这个节点的做孩子；

红黑树的查找：同二叉搜索树，对于红黑树的查找来说和二叉搜索树没有任何的区别
红黑树的添加：添加分为两个步骤：查找：遇到四节点分裂-->添加-->修复
	红黑树新加的节点一定是红色，红黑树再添加的过程中，要保证遍历的节点是非四节点，想上分裂，中间节点由黑变红，左右节点由红变黑->可能导致红黑树不在左倾-->怎么办，添加完成后自底向上逐层修复
红黑树的修复：
红黑树的删除：如果删除的是非最底层结点  先替换  再删除；如果删除的确实是最底层结点（非单key-->直接删除；如果是单key-->借结点再进行删除，但是结点不一定可借）
	如果删除的是最大值，则要保证路径上结点的right不是红色同时right.left不是红色；如果删除的是最小值，则要保证left孩子不是非单key，即mid.left不是红色同时mid.left.left 也不是红色；

使用红黑树不使用二叉平衡树？红黑树是局部变换，修复比二叉平衡树简单


B树：节点最多有m棵子树  2.m/2



手写集合类的作用？java的集合类有什么作用，用来存储数据；
集合类的三个角度：实用角度：数据容器（希望比较快速的进行增删改查）底层引入了组织方式：数据结构，容器内部的数据按照哪种结构组织（本质目的是为了高效和快速总是落实到代码上怎么表示数据结构，用什么对象关系来描述数据结构，就回到数组和链表上）数据结构是抽象的一种概念，用什么对象关系具体在内存上是实际存在的
要求：1. 至少要知道什么是线性表，栈队列树，二叉树，二叉搜索树，自平衡二叉搜索树，红黑树；2，多写代码
面试会问哪些内容：数据结构的理论，红黑树几个问题

collection集合类：记忆（每一个集合类的特点，记忆api，hashmap重点记忆）
面试重点：ArrayList和hashmap
Se面试点：string，多线程，垃圾回收的几种算法机制；集合类；网络编程，流

java的集合类分成两个体系：一个是collection：作为数据容器存在，存储的是单个元素；2.map作为数据容器存储的是键值

怎么记忆：集合类的特点。我们写你们记，（记忆顺序）
collection的特点：1.collection是collection集合体系的顶级接口；2.collection的一些子实现是有序的，另一些子实现是无序的；3.一些子实现允许存储重复元素。。。4.一些允许存储null另一些不允许存储null；
将入一个接口是另一个接口的子类，它想对父接口进行功能增强
collection的主要方法：
集合类的添加方法：add（E e），addall（collection<? extends E >C）//可以将collection里面的东西往cllection2里面copy一份；3.clear清空操作；toArray[]
toarray 是一个泛型方法，根据参数可以返回一个和参数累次能够相同的数组；当我们给定一个和元几个类型不相同类型的数组，有可能会报错，如果我们给定一个数组长度不够（数组长度小于collection中的元素）穿进去的数组和返回的数组长度不相同时，返回的长度是原集合类中的长度；如果长度不够。和集合类中存储数据量相同，返回的数组和做参数的数组；
如果给的数组过长，那么返回的数组和参数的数组是同一个数组，并且这个数组的collection有x个元素，这个数组的前x个位置存的是collection里面的元素，x+1存储的是null
<E>iterator:获得一个迭代器，可以实现遍历：原理是：collection类继承了iterable接口，拥有了一个定义的方法iterator以为着所有的collection的子类中都要实现iterator方法，collection的所有子类底层结构未必一样，遍历方式必定存在差异，每一个collection的子类都应该拥有符合自己数据存储方式的iterator方法，这个iterator方法返回的对象是一个内部类对象
iterator是一个接口：有三个方法：hasnext()，next()和remove()（删除刚刚遍历过的元素）
面试：迭代器开始指向第一个元素之前，iterator.next()指向的是第一个元素和第二个元素之间；
iterator是一个内部类，保存一些标记，标记元数据，并没有从原数据中复制出新的标记，因为这样遍历效率更高，相比较toarray，toarray的遍历是赋值原数据放到数组里面，复制效率不高
删除操作不能在未遍历之前删除，也不能连续的删除，因为删除操作是删除刚刚遍历的结果，所以不希望在遍历的过程中用遍历删除，它希望你在做iterator遍历的目的更偏重遍历而不是删除）

为什么key-value会更加常用：因为key-value有自我描述性
hashSet的底层是hashmap
取余用&？？？？





并发修改异常
加锁使效率降低；
modcount：记录集合类的修改次数
在多线程情况下为了避免一个线程在遍历而另外一个线程在修改会导致遍历结果不对，为了避免这种情况出现又不想用加锁的方式处理-->加锁会导致代码的运行效率降级；所以选择用标记的方式来实现数据同步（expectModCount=modCount）,我们会在遍历的iterator对象为胡一个标记，一番元集合的数据被别的线程修改，那么立马可以检测出这个修改，由于设计不够完美，会导致单线程的情况下，也会产生并发修改议程（当）

foreach：
foreach/增强for循环/加强for循环
如果使用foreash循环，不要再foreash循环中修改集合数据，因为foreash循环底层是iterator迭代，会抛出并发修改异常
意味着使用foreash樽还不可以删除元素---->没有这个需求
foreash底层（除了数组）都是使用iterator遍历、编译，意味着foreash循环中，不要通过元集合的修改方法去修改元集合类的修改方法来修改元集合类的数据（添加或删除改变元集合类的结构性修改）
foreash循环一般用来遍历集合类，但是也可以用来遍历我们自己实现的一个类型，要求自己实现的类型中包含iterator方法；数组的foreash和集合类的foreash循环具有不可比性，数组的foreash循环底层是fori循环；


List以及list的子类：
如何记忆：谁的子类接口-->描述数据结构 底层结构 初始和扩容 有序/允许重复/null  线程安全

1.特点：1.list是collection接口的子接口；2.描述的是线性表这种数据结构（线性表：有序序列-->有下标/有下标api）3.必定有序；4.允许存储重复元素；5.允许存储null
从语言使用的角度来讲ArrayList ...=newArrayList();不太好
原因是接口定义的是规范
boolean add<E e>//添加方法   		



listiterator ：是iterator的一个子接口，接口是另外一个接口的子接口，增强功能；

7-15
list：
add(E e):添加到要遍历的位置并且可以连续添加；
set（E e）：修改是修改刚刚连理过的元素的位置，可以进行连续修改；
nextIndex():获取下一个遍历的位置下标；
int previousIndex()：获取下一次向前遍历要遍历元素的下标；
sublist：切割list  ！！！视图；并没有真正的切割出数据仅仅是维护原数据的一些标记，标记哪些元素是切割出来的范围，看上去好像是copy了一份数据实际上并没有，它里面的数据还是原数据；如果是removesublist中的数据，原数据也会remove；
sublist是一个视图方法，视图来源于数据库“虚表”：给原本的数据划分不同的表，不同的表持有不同的数据引用
sublist没有真正的切割方法，它里面维护的只是一个标记；
list的子类：

ArrayList：
特点：1.ArrayList是list接口的子实现，表示一个线性表，底层结构是数组；4.数组的默认初始长度10，扩容机制*1.5；5.有序6.允许重复元素存储7.允许存储null；8.线程不同步
为什么要继承抽象类abstractList：collection-->abstractcollection---->abstractlist----->arraylist;因为一些功能性方法，他不想每个类中都实现一遍，所以写到abstract里面；
可选操作：接口定义了一个方法，子类可以实现也可以不实现，并抛出一个异常；
底层结构是数组（源码分析）：ArrayList的构造方法中将空数组赋给this.elementdata；在第一次添加元素的时候，才把数组变成长度为10；
构造方法：ArrayList()构造一个初始长度为10 的空列表；ArrayList(int initialCapacity)构造一个具有默认初始容量为10的底层数组；ArrayList(Collection<? extends E> c)构造一个指定元素的列表，这些元素是按照...复制到ArrayList当中；
API：add;add(index,element);addall();clear();contains();get();indexof().....
void trimtosize（）：消减容量减少内存空间浪费；但是没啥用，
void ensurecapacity（int min）：把ArrayList的底层数组编程指定长度，但是这个长度应该是要大于原本的底层数组长度；
clone（）：返回的是ArrayList实例的浅表副本；
clone()方法：
clone()复制一个浅表副本；list.clone()，clone只clone对象本身和对象的引用数组，不clone底层数组；
iterator()方法：cursor指向下一次要遍历的位置；lastreset指向刚刚遍历的位置
ArrayList的listiterator的方法：

arrayli和hashmap的区别：
ArrayList和linkedlist的区别：17.36分
ArrayList和vector的区别：先说相同点；然后再说不同点；

vector：
vector是list接口的一个子实现，描述的是数据结构的线性表底层结构是数组，底层的默认初始长度10，数组的扩容机制（如果没有增量，扩为原来的两倍，如果有增量，扩大增量个），有序，允许重复，允许存储null，vector线程安全的
vector的构造方法：vector()、vector()、vector()、vector(int init)

stack：
特点：stack第vector的一个子类(stack想复用vector的底层结构，参数变量以及方法)；描述的数据结构是栈；底层结构是数组；默认初始容量是10 ，默认扩容机制是2倍；有序，允许重复，允许null；线程安全；
注意：如果使用stack的时候尽量不要使用他从vector中继承的方法，因为既然使用了stack就是希望它作为栈而存储，而非普通的线性表
如果我们真的需要一个栈，可以优先用deque接口下的具体实现，因为的确这个接口定义了栈的数据结构操作；

linkedlist：
特点：
1.linkedlist是list的一个具体实现（同时它还实现了的确接口）2.他所描述的数据结构线性表、队列、双端队列、栈3.底层结构是一个双向链表；4.允许有序；5.允许存储重复元素；6.语序存储null；7.线程不安全；
deque这个接口：描述的数据结构可以值队列双端队列或者是栈
构造方法：linkedlist()；linkedlist(linkedlist);


queue：
特点：queue接口是collection的一个子接口，描述的数据结构是队列，2.有序（添加或者删除的位置可预期）；3.允许存储重复元素；4.不允许存储null(linkedlist除外)；
queue的删除操作，是以返回一个null值作为标记，标记没有元素存储了
api:add（e）上限时候抛出异常；offer（e）上限时候返回特殊值；remove抛出异常，poll()返回特殊值
注意：如果queue存储元素的时候，没有位置或者空间，可以存储了，如果使用add方法抛出异常；如果offer存储元素，返回false；如果queue存储元素梦里面没有内容remove抛出异常，如果使用poll返回null



deque
特点：deque是queue接口的一个子接口；描述的数据结构是双端队列、普通队列和栈，有序，允许存储重复元素；不允许存储null(linkedlist除外)
API：

arraydeque：
特点arraydeque是deque的一个具体子实现；arraydeque描述的数据结构是普通队列，双端队列，栈；底层是一个数组循环数组；默认初始容量是16，扩容机制是扩容为原来的2倍；有序；6.允许存储重复的元素7.不允许存储null，8.线程不安全
在给定长度的构造方法里，如果我们给定一个长度小于8 的话底层数组创建一个长度为8 的数组，如果给定的值大于等于8，那么这个被创建的底层数组的长度大于给定值的最小的2的幂指
2的幂指和
循环数组的好出，不需要再每次删除之后，移动n-1个元素，只需要删除标记；

4.blockingqueue：阻塞队列：
如果队列的大小是一定的，当队列存满的时候添加线程阻塞，当队列为空的会后添加线程阻塞
特点：阻塞队列有一些阻塞方法，比如
普通阻塞方法和超时阻塞方法：
阻塞队列经常用于缓存的场景；


Map：
java中的集合类分为两个集合体系，一个是collection一个是map；区别collection存储的是单个元素，map存储的是key-value数据也称作是键值对（我们在研究map下集合的时候关注的核心店在key上）；3.有的子实现key是有序的，有的子实现key是无序的；4，有的子实现key是不允许重复的，有的是不允许重复的，有的可以存null有的不可以存null
api：put   size()存储多少份数据；clear()清空数据;isempty()判断是否存储key—value数据；containskey；containsvalue；get（key）根据key获取value；void putall(map及其子类)添加所有；set<K> keyset（：获得map中key的集合，获得键集）；


hashmap（重点中的重点）：
hashmap的结构：数组+链表+红黑树，
特点：hashmap是map接口的一个具体实现；2.hashmap的底层结构式数组+链表+红黑树(红黑树是jdk1.8版本的结构)；3.数组的默认初始长度16（第一次添加的时候进行扩容扩容到16），数组的扩容机制（扩围原来的两倍）；4.hashmap存储key是无序的；5.hashmap不允许存储重复的key值；6.hashmap允许存储nall键；7.hashmap线程不安全；8.hashmap的默认加载因子是0.75（我们也可以在构造方法中传入构造因子）//9.hashmap中hash值得计算=哈希值异或哈希值右移16位；10.如果我们在构造方法里，给定一个长度那么hashmap会创建一个底层数组长度大于等于给定值得最小的2的幂指的一个数组；
在执行put方法的时候，会有一次resize()方法用于执行扩容
加载因子：类似于饱和度，数组存储元素(key-value)到一定容量的时候就会扩容数组，以避免链表和红黑树过多、多长导致存储的效率降低//扩容的阈值=加载因子*数组长度
注意：hashmap中是怎样存储key-value数据的；1.hashmap在存储一份key-value数据的时候，先吧key取出来计算；key经过计算得到一个int类型的hash值；3.把经过集散的hash值和hashmap的数组长度取模得到下标；如果这个下标位置没有元素，把这个key-value数据存到这个位置(存储的是一个节点类型，这个节点累次能够里面包含key，value……)5.如果这个下表位置已经存储了节点，判断key值和这个下标位置的这些已经存在节点中的key值是否重复，如果重复不添加，如果不重复，添加到这个位置(链表的尾部)；6，如果链表过长，把链表转化为红黑树
node<K,V>[] table；//hashmap的底层数组
从主观上我们瓷王每一个key都能散列到数组的不同的位置

构造方法：


hashmap判断key值重复的依据：
如果这个要散列的下标位置从来没有存储过元素那么久直接存储，如果这个要散列的位置；我们存储到数组位置的key-value数据，实际上数组存储的是一个node类型的节点，这个节点包括hash，key，value，next
12.在hashmap中判断key重复的判断条件，先判断hash一样，然后判断key是否相等胡哦哦这是equals；（）
13.如果我们用一个普通的java对象来充当key 的时候，我们希望比较的是对象里面存储的内容，要根据这个对象里面的参数重写hashcode和equals方法（也就意味着金重写equals是不行的）；如果我们希望这两个user对象被hashmap看做是同一个key值得话，需要重写user类型的hashcode和equals方法
（如果两个key的hashcode是一样的，并且两个对象equals，那么对于hashmap来说这两个key就是重复的）；
14.如果要存储的key-value数据，这个key值已经在hashmap上存在，那么我们会用新的这份key-value数据的value来覆盖已经存储到hashmap上的（已经存储到）
15.链表在hashmap存储中如果多个key-value散列到同一个下表位置，key值也不重复，那么这个位置就会构建出一个单链表，如果这个单链表过长就会转换为红黑树，过长指的是链表长度超过8 编程9 的时候
hashmap链表转化为红黑树
16.在hashmap中，链表长度超过8达到9的时候，一定会转换成红黑树吗？不一定，在树化操作中有两个选择，如果底层数组长度小于64的，那么我们会对底层数组扩容，如果底层数组长度是大于等于64 的，会对链表进行转化转化成红黑树；
扩容，key-value的hash值是不变的，hash来源于key的hashcode，数组长度变了，驱魔结果变化-->存储位置可能变化
17.如果一个key-value原本在此表为x的位置，当发生扩容的时候，它只可能重新散列到两个位置，（原本的位置或者是x+旧长度），原因是因为：数组长度是2的幂指
18.红黑树什么时候转化为链表：有两种情况会导致红黑树转换为链表1.删除元素的时候(删除的是红黑树上的元素)；2.在扩容的时候有可能会导致红黑树转换为链表（扩容会把一个元素位置的数据拆成两个）
hashmap在删除的时候会转换为链表，删除的时候的判断逻辑：根节点的左右节点、根节点、根节点的左节点的左节点只要有一个是null，就会在删除操作的时候把红黑树转化为链表；
hashmap扩容的时候的判断逻辑：由于扩容的时候，红黑树节点会散裂成两部分（旧位置或者是旧位置加长度）这两个位置经过散列之后，散列的key-value数据是小于等于6的时候，就要由红黑树转化为
看源码要求：看源代码不要过度解读，不要一句一句看源代码，--->看核心逻辑技巧：ctrl+f；Ctrl+alt+左右
19.存储到红黑树（特殊的二叉搜索树，是要能比较大小）
20.已经存储到hashmap中的key-value数据马步谣通过引用来修改key值















