JVM中标记清除垃圾回收算法的核心思想：
假设空间为10的数组中有8格式元素分别是abcdefgh现在要删除abc三个元素，为了避免后面的defgh这几个数据发生变动，我们记录已经删除的数据。所以每次删除操作并不是真正的数据发生了搬移，只是记录数据已经被删除。当数组没有更多的空间用来存储数据是我们触发一次真正意义的删除操作，这样可以极大减少删除操作引起的数据迁移。

在Java中使用ArrayList，存储空间不够用时，ArrayList会自动扩容到原来的1.5倍大小，Java中ArrayLIst无法存储基本数据类型比如int，long，需要封装成相应的Interger类和Long类，而且Autoboxing和Unboxing也存在性能的消耗，如果特别关注性能就可以考录使用数组来代替使用ArrayList这种数据结构

在使用多维数组是采用数组的定义会比较直观，而采用容器定义的话则需要定义成ArrayLis<ArrayList>array 这种形式看起来不怎么清楚；
数组的下标为什么会选择从0开始：因为数组的下标其实相当于偏移这种感觉可以在数组定义时体现出来，因为要计算存储数组所需要的地址，如果说从0 开始，第i个位置的地址就可以表示为i乘以单个元素所占的字节数，但是如果从1开始的话就需要进行一步减法操作，对于CPU来说就要相应的多运行一次减法指令所以数组选择了从0开始进行编号，还有一个比较重要的原因是历史的原因，因为C语言的设计者运用了从0开始的下标方式，而后Java和JavaScript的设计者也都采用了这种设计方式，可以很大程度上节约语言学习的成本，

抽象类在使用中的注意点：1.abstract不能用来修饰构造器，属性，代码块等结构，不能用来修饰final类，无法被继承的类，不能修饰私有方法，静态方法和final方法，不能被重写的方法，抽象类中可以没有抽象方法但是意义不大。
（又一个小细节）抽象类的使用规则，可以在main方法中用父类的引用指向不同的子类对象，然后通过强转的方式来访问子类对象中的成员或者是被重写的方法
在Java8 以前接口的方法都是默认的抽象方法，但是在Java8 及以后的设计中Java提供了默认的实现方法就是静态方法：加入静态方法的原因是：1..在计算机系统变复杂后接口会有很多要实现的子类，如果使用抽象方法的话，子类必须具体化，所以会报错，多以会引入默认实现方法
类加载的几个时机：1.运行main方法，2.new一个新的对象3.访问静态成员4.触发子类类加载会触发父类类加载
think in java:使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
成员内部类的成员特点：1.成员内部类中不可以定义静态成员变量，2.可以定义static final修饰的全局常量，但这些全局常量不能触发类加载，比如基本数据类型和string类型的字面值常量的赋值；成员方法不能定义成静态；
外围类<----->成员内部类的相互访问：外围类访问成员内部类分为两种情况：1.在外围类的成员方法中访问内部类成员需要直接创建内部类对象，然后去访问；2.在外围类的静态方法中访问内部类的成员：需要首先创建外围类对象，然后在此基础上创建内部类对象，然后通过对象访问成员。内部类访问外围类：不同名的情况下直接访问，同名的情况下用 外部类名.this.成员变量名 访问；
外部类和成员内部类的相互访问：外部类访问成员内部类成员：先创建外围类对象，然后再外围类对象的基础上创建内部类对象，在接收对象时需要明确指出对象时谁的对象：语法是：外围类名.内部类名 内部类对象名 =Xxx;成员内部类访问外部类：new 外部类().外部类对象的方式访问；

静态内部类<---->外围类之间的相互访问：1.静态内部类访问外围类：直接创建外围类对象，然后直接用对象名点的方式访问即可，2.外围类访问静态内部类：直接创建静态内部类对象，不用管外围类对象；
静态内部类<---->外部类之间的相互访问：1.外部类访问静态内部类：语法：外围类类名.静态内部类类名 对象名 = new 外围类类名.静态内部类类名（）；2.静态内部类访问外部类成员：直接创建外部类对象即可，创建和访问都受到访问权限的限制；

局部内部类的一些特点：1.局部内部类又一个作用域，出了作用域就访问失效，所以只有在方法的内部才能访问到局部内部类成员；2.它的用途主要是在方法中需要一个对象来解决问题但又不希望外界能够感知到这个对象；3.局部内部类进行类加载的时机：在方法里面创建类对象的时候加载
局部内部类<---->外围类1.局部内部类访问外围类：在不同名的情况下可以直接访问到，同名情况下考虑使用外围类类名.this来访问；如果是静态成员方法中的局部内部类需要创建外围类对象下能访问成员，如果同名就用对象名区分；2.外围类访问内部类，访问不到，因为出了范围就会失效；
外部类<---->内部类：1.外部类访问局部内部类，访问不到；2.内部类访问外部类直接创建对象即可；
局部内部类的用途：在方法调用其他方法时，如果需要一个对象可以考虑用局部内部类，在写一个方法返回值时，如果要返回接口和抽象类的子类对象时可以用一个局部内部类


6月22
局部内部类，匿名内部类的注意事项：
在局部内部类的成员方法中使用方法的局部变量，可以访问局部内部类但不能修改变量，如果在局部内部类中访问方法的局部变量，需要修改的变量是final修饰的常量，或者实际上就是一个常量：（方法局部变量和对象生命周期的冲突）方法在栈中，而对象在堆中，对象在方法出站后完全可能存在并被引用指向，Java开发者让JVM在创建内部对象时，复制了一份变量成对象的成员变量，解决了冲突问题，但是仍然存在同步问题（在对象内部修改了成员变量，外部的变量也会发生修改，但是Java开发者没有采取同步的概念，而是直接不让内部类进行修改，所以在局部内部类中访问方法的局部变量改局部变量实际上是一个常量）
局部内部类访问局部变量，该局部变量实际上隐含了final修饰是一个常量，在Java7之前需要写final，但是在Java8之后将final隐含在了底层
Java内部类的使用场景：1.内部类可以无条件的访问外围类的所有原素；2.超级封装；3.用内部类可以实现多继承
（练习：用接口来测试同名的情况下的访问实现）
实际开发中，不推荐内部类，因为当内部类被外围类其他类引用时可能会导致内存泄漏，因为GC无法会后对象的内存；
生成一个类名或接口的子类对象，也就是说匿名内部类的语法隐含了继承和实现：把子类类名和对象也匿名了，匿名内部类不是一个类而是一个对象，很多人会把匿名内部类称作是匿名的局部内部类对象。
匿名内部类的使用方式：1.直接创建匿名内部类对象去使用：new IA（）{方法重写}；使用方式1：直接使用：当成匿名的匿名内部类对象>new IA（）{方法重写}.test；>访问特点：不需要引用接收，定义匿名子类独有的成员，并且可以访问子类独有的成员，缺点是只能用一次，没有引用指向；方式二 用引用接收，只能用父类引用接收，优点是接收后可以多次使用该对象，缺点是无法访问子类独有成员甚至不能做出强制类型转换
（lambda表达式的独特使用）
lambda表达式不是必须要使用的，大多数情况使用lambda表达式是为了更加减单化代码：lambda市西街口的匿名内部的简化，对抽象类和普通类不能简化
lambda表达式是对接口的匿名颞部类的简化，首先需要一个接口，lambda表达式要求该接口当中只能有一个必须要实现的抽象方法，Java当中把这类接口称作是功能接口（function interface）用functionInterface注解标记它；功能接口中有默认方法和静态方法，他们不需要实现，功能方法不一定只有一个抽象方法，因为有些抽象方法不需要子类实现，如果抽象方法是Object类当中存在的方法，name就不用子类实现，因为object类中已经实现了
lambda表达式语法：（形式参数）->{方法体}；形式参数是功能接口中必须要实现的抽象方法的形参列表，->表示lambda表达式运算符“goes to”方法体：功能接口中必须要重写的方法体；为什么lambda表达式对接口的要求必须是功能接口，因为限制了只能重写一个方法，并且不能增加额外的成员
lambda表达式的本质和匿名内部类是一样的，都创建得出是接口的实现对象
四种推断方法：1.用父类接收；2.直接告诉编译器lambda表达式的数据类型但是不接受它，在lambda表达式之前加上（接口名）然后接收方法；3.如果方法的形参是一个接口，name编译器就已经知道要穿什么类型的对象，so可以把lambda表达式写在形参的位置，借助方法来完成推断；4.将lambda表达式写到返回值的位置；
lambda表达式的简化原则：lambda表达式简化的前提，功能接口只有一个要实现的抽象方法；形参能简化（因为抽象方法只有一个，参数类型是固定的）当形参只有一个时可以省略小括号，如果不是一个的情况下括号不能省略；方法体的简化当语句只有一条是可以把大括号省略掉；如果抽象方法有返回值并且返回值语句只有一条，可以返回return;->在某些情况下也是可以简化的，lambda表达式出克自定义方法实现外还可以指定一个方法作为实现 (形参)->已实现的方法，直接用接口的名字 子类对象名 = 方法归属者：：方法名；lambda不仅可以指向已经实现的方法开可以指向jdk中已存在的方法
lambda表达式没有自己的作用域，里面存在一个闭包的问题；通过lambda表达式引入了函数式的编程。

首先查看方法的声明：public表示没有权限限制，final表示可以笨继承但是补鞥被重写，native表示是一个本地方法表示用C或者c++方法实现的方法本地方法不是用Java代码实现的，Java程序员无需关心本地方法的实现，class<?>整体处在返回值类型的位置，表示该方法会返回一个类的对象，<?>表示泛型，泛型会在编译时期限制代码的书写。运行时对象可以在程序运行期间获取类型信息，包括那些成员方法或者是注解，甚至可以获取成员变量调用方法创建对象getname()获取权限定类名，getsimplename获取类名
对于同一个类来说，因为类加载只有一份所以堆同一个类来说地址是一样的；如果不是同一个类那么他们的运行时对象一定不同，可以根据这个特点来判断两个类是否是同一个类生成的
getclass（）.getname与getclass().getsimplename:getclass().getname()返回的是一个string类型的字符串，而getsimpleclass返回的所做的操作是首先会判断是否是一个数组，如果是数组的话判断数组的组件类型，


6月23
getclass获取的是一个类运行时的对象class对象类对象，这个方法用来获取对象，这个class对象是类加载是jvm在堆上创建的 ；类加载只有一次，所以对一个类莱索class对象只有一份；so类加载只有一次所以地址值相同
==比较的是地址，equals 比较的是内容
string对象具有不可变型，一旦改变某个字符串，就是创建一个新的字符串

instanceof和getclass有什么不同，instanceof可以接收子类对象，getclass必须要传入同种类型的对象，用lang instanceof任何一个对象都返回false
euqala方法占主体地位，一旦equals认为两个对象相等，hashcode也必须相等，所以equals方法和hashcode方法要么都重写要么都不重写

6月24日

为什么book类定义的getinfo方法没有加上static？在之前的学习中，我们知道有主方法直接调用的方法必须加上static，但现在情况有些变化，因为book类的getinfo方法会由对象调用，与之前的调用形式不同，所以没有调用，同时可以这样理解，如果对象调用的方法定义不加static，如果不是由对象调用的方法才加上static；
关于堆内存和栈内存的补充说明：堆内存保存对象的真正数据，都是每一个对象的属性内容，栈内存保存的实际上是堆内存的空间地址，因此只要看见了关键字new不管在任何情况下都表示需要开辟堆内存空间；
如果使用了没有实例化的对象会如何？如果只是声明了对象没有给对象实例化就会报空指针异常的错误nullPointException，这种异常是因为在使用引用数据类型是没有为其开辟堆内存空间；
关于Gc垃圾回收处理的深入分析：GC的功能出了垃圾回收外还包含了见识对象的地址大小和状态，对象的引用回报存在栈内存中，而对象的具体内容回报存在堆内存中，当GC检测到一个堆中的某个对象不在i栈所引用的时候，就会不定期的对这个堆内存中保存的=对象进行回收，GC也可以最大限度的防止内存泄露；
GC提供了多种不同的处理分类：1.引用计数：对一个实例化的对象如果被引用了就让count值+1，当对象使用完毕count-1，当引用计数减到0时GC就会瘦；2.跟踪收集：从root set（包括当前正在执行的线程、全局或者是静态变量、JVM hangles、jndi handles）开始扫描有引用的对象,如果某个对象扫描不可达，说明这个对象已经死亡，GC可以对其进行回收；3.基于对象跟踪的分代增量收集：将所有的对象回收要根据堆内存的结构划分来收集：小1：基于对象跟踪：是由跟踪手机发展而来的，分代是指对堆进行了合理的划分，将JVM将堆划分为以下三代：YoungGen（新生代，使用minorGC回收）younggen区里面的对象的生命周期比较短，GC将对象进行了回收的时候采用了复制拷贝算法。，简单的理解younggen每次都会在每个对象创建的时候才会分配对象，然后通过三次扫描和转存，吧无法分配的空间通过GC进行回收，并且把通过三次扫描档空间放到oldgen中；B.oldgen(年老去使用major GC进行回收)younggen将对象放到鸟老区之后会检测oldgen剩余空间的大小，如果说oldgen的剩余空间小于要保存对象的大小，则直接进行一次fullGC的回收，对整个堆进行扫描和回收，如果剩余空间大于要保存的对象，则会根据条件（headpromotionfailure的配置是否允许分配内存失败，即整个oldgen空间不足，而young空间中Eden和survivor都存活的极端情况）进行GC的回收；C.持久区：要存放加载进来的类信息，包括方法属性对象池等，满了之后可能会引起out of memory错误；小2.增量收集：不是每一次都全部收集，而是累积的增量收集；
封装：为了数据验证，更加可控有效，类中的属性要求使用private修饰体用setter和戈塔特人两个方法供外部进行访问；
构造方法和普通方法的区别？构造方法为什么不使用void进行修饰，普通方法也可以完成一些初始化操作吗？ 1.构造方法和普通方法在调用时有明显的区别：构造方法是实例化新对此昂的时候值调用一次，普通方法是在实例化对象产生之后，通过对象.方法调用多次。2.在构造方法盛世永了void其定义的结构就和普通方法完全一样，而程序的编译是通过定义结构来解析的，所以不能有返回值声明，与普通构造方法方法最大区别在于：构造方法要通过new关键字的时候直接调用的，是与对象创建一起执行的操作：要通过普通方法进行初始化，就表示要先调用无参构造方法实例化对象，在利用对象调用初始化方法比较啰嗦。
构造方法的核心作用：在时机的工作中构造方法的核心作用是，在类对象实例化 的时候设置属性的初始化内容，构造方法是为属性初始化准备的，在本程序中由于已经明确定义了一个有参构造方法就不会在自动生成默认的构造方法，即一个类中至少保留一个构造方法，另外需要注意的是在类中结构包含的属性、构造方法、普通方法的编写顺序问题：首先编写属性（必须封装，同时提供setter,getter的普通方法），然后编写构造方法，最后编写普通方法，这是一个习惯；
关于属性默认值的问题：在对象实例化的过程中一定要经理类的加载，内存的分配，默认值的设置、构造方法
匿名对象：没有栈内存只想对内存的对子昂称作是匿名对象，只能使用一次，
匿名对象什么时候使用：对于匿名对象开发者必须清楚，开辟了堆内存空间的实例化对象，只能使用一次，使用完成后就必须被GC回收了
阅读《Oracle开发实战经典》

不建议使用多维数组：从二维数组开始实际上就进入了一个多维数组的概念范畴，三维数组理解成是一个=三维图形的结构，维数越多概念越复杂
数组的api：数组的赋值system.arraycopy(arr,arr,int ,int);数组的排序java.util.arrays.sort(arr);
==h和equals：==不能够准确地实现字符串的比较，因为strb使用new关键字开辟了新的内存空间所以在使用==比较时比较的是数值，所以地址数值不相同的string类对象在使用==比较时其结果一定会返回false，而strb和strc指向的是同一块堆内存空间所以地址数值相同返回的结果就是TRUE；equals是string提供的一种方法专门应用于string内容的比较
引用数据类型都可以使用==进行比较，但是比较的并不是内容而是地址值的数值内容，这种操作常常用在判断两个不同名的对象是否是指向同一块内存空间
string的两种赋值方法的比较：直接赋值方式为string类对象实例化智慧开辟一块堆内存空间，并且还会有一个作用是在相同的内容情况下不会开辟新的堆内存空间，而会直接指向已有的堆内存空间；
string的动向设计模式：在JVM的底层时机上会存在一个对象池，当代码中使用了直接赋值的方式定义一个string对象时，会将字符串对象所使用的的匿名对象保存到对象池中，如果后续有其他的string对象也采用相同的赋值方式，并且设置了同样的内容是，将不会开辟新的堆内存空间，二是利用已有的对象进行引用分配从而继续使用。使用构造方法开开辟两个堆内存空间，其中一块空间将会成为垃圾并且不会自动进入池，但是用户可以使用intern（）方法手工入池
怎样解决需要频繁修改字符串的问题：使用stringbuffer或者stringbuffer类来代替：这两个类表示可以修改内容的字符串类型；但是Java开发中绝大多数采用的多事string类型，如果只是进行简单的字符串修改，对于产生的垃圾问题也没必要过于在意；
关于string类中startswith方法的使用在（Javaweb开发实战经典（高级案例篇）中有详细的介绍）
在这里我想到了一个问题和解决办法，怎样处理姓名中含有空格的情况，特别是俄国人那种：办法是先用空格拆分，然后接收，然后让字符串比较，最后还要合并；
关于this调用构造的限制：在使用this构造方法是，存在着两种重要的限制：1.使用“this”调用构造方法形式的代码只能够放在构造方法的首行，因为构造党发是在类对象实例化时调用的，多以构造方法间的相互调用，只能在构造方法中编写；2.在进行构造方法互相调用时，一定要保留调用的出口，用来防止出现调用方法发生死循环



final修饰数组：表示数组的地址不可变但是内容和长度是不可变的，但内容修改起来并不方便。所以每次修改string对象的内容都会创建新的string对象。string对象不可变的设计是为了可以实现共享，
字符串的字面值常量在Java的编译时期就能确定它的取值，所以字符串的字面值常量在程序的编译时期就加了“静态常量池”（二进制的字节码），当程序执行起来后，在尅加载时期，居民就会悠闲从惊天常量池中读取字面值常量，然后加入运行时常量池，so在程序执行是，对象就在于运行时常量池当中，运行时常量池在堆上；
string s = "helloworld"和new…… 的区别，前者string在堆上指向堆上的常量池当中并指向堆上的value数组，后者在堆上创建helloworld对象，并且共享前者的value的数组（string对象不可变value数组的内容也不可变，所以他们共用一个value数组）
equals和hashcode都是通过字符数组来实现重写的
charat用于将只有一个字符的字符串转换成字符，用作scanner中

6月25日

链表的标准形式结构：1.客户端不用关注具体的node机器引用细节，只需要关注link类中提供的数据操作方法；link类的主要功能是控制node对象的产生和根节点，node对象主要负责数据的保存以及引用关系的分配
链表的基础功能：public void add（数据类型 变量）：向链表中增加新的数据；public intsize()取得链表中保存的元素的个数；public boolean isempty():判空；public boolean contains(数据类型 bianliang):判断某一个数据类型是否存在；public 数据类型 get(int index)根据索引获取某一个元素；public void set(int index,数据类型 变量）使用新的数据类型替换指定索引的内容；public void remove(数据类型 变量）删除指定的数；public 数据类型 [] toArray() 将链表以对象数组的形式返回 ；public void clear()清空链表；
每种数据类型都有一个链表会不会太麻烦了？可以考虑利用继承来简化它，采用链表一对多的关系来实现操作；
关于重写的执行 问题：要注意以下重写代码执行结果的分析要素：1.观察实例化是哪个类，2.观察这个实例化的类里面调用的方法是否已经被重写过；
什么时候会使用到方法的重写这个概念？当子类发现功能不足时可以考虑重写：如果发现父类的方法名功能不足，但是又必须要使用这个方法时可以考虑通过重写的方式来解决。
多态性：方法的多态性：重载与重写；对象的多态性：父子类对象的转换；
对象的多态性的实际作用：在实际开发中，对象向上转型的主要意义在于参数的统一，也是最为主要的用法，而对象的项下转型是指调用子类的个性化操作方法
外部抽象类不允许使用static声明，而内部抽象类允许使用static声明使用static声明的内部抽象类就相当于是一个外部抽象类，继承时使用“外部类.内部类”这种形式
隐藏抽象类子类：利用static可以在抽象类中定义不受实例化对象限制的方法，在抽象类A中用私有权限写一个具体类B之后再调用，用户不需要知道抽象类的子类，只要调用类中的方法就可以取得抽象类的实例化对象并且调用方法；
好的Java代码应该遵守两个标准1.客户端调用简单不用关注具体的实现细节；2.程序代码的修改不影响客户端的调用，使用者可以不去关心代码是否变更
实际开发中，关于接口的使用建议：在定义某些公共操作时一定要定义接口；有了接口就需要利用子类完善方法；如果是自己写的接口，name绝对不要使用关键字new直接实例化接口子类，应该使用工厂类完成
基本数据类型的包装类：是为了解决“基本数据类型不是对象”所提出来的，jdk给出了8种基本的数据类型可以分成两类：1.对象性包装类：character和boolean,2.数值型包装类：byte,short,long，integer，long，float，double;number是一个抽象类，里面一共定义了6个操作方法---value;装箱操作通过new一个对象来完成，拆箱操作通过xxxvalue（）方法来完成，也可以通过类型转换来实现自动装箱和拆箱，
利用object可以接收全部的数据类型：流程是：基本数据类型》自动装箱》向上转型为object；
什么时候使用包装类？什么时候使用基本数据类型？使用包装类的最大的一个好处是可以存在null数据，这在与数据库的操作上会显得特别方便，尤其是外键数据的处理上。而出了简单的Java类之外大部分情况程序中出现的数据使用基本数据类型会比较方便
单例设计模式：构造方法私有化之后怎么在类的外部通过实例化对象访问到对象的成员方法？单例设计模式：1.在本类中产生本类的实例化对象2.为保证类加载时候就实例化在前面加关键字static3.类中全部属性都应该被封装，所以要编写相对的get方法来实现调用；这样做的目的：可以控制一个类中实例化对象产生的个数 并且，如果调用类中定义的操作，那么显然需要一个实例化的对象，这时就可以在类的内部使用static方式来定义一个公共对象，并且每一次通过static方法返回唯一的对象，这样做不管外部有多少次调用，最终只能产生唯一的对象（类加载只有一次），这种设计模式也称作是单例设计模式，例如电脑的回收站就应用的是单例设计模式；singleton
多例设计模式：其他和单例模式一样只不过每次不创建对象，而是直接引用class中的静态方法
Java中的新特性——可变参数：适用于不知道方法中需要传多少个参数语法是（int……num）本方法用于多个参数的处理并统一使用一个数组进行接收，开发中已经大量使用可变参数，例如国际化应用反射机制和之后spring框架都已经大量使用可变参数
foreach循环：iter;此时for循环在每次循环时自动将当前数组或集合中的全部内容取出，这样就避免了索引问题，
静态导包：import static 包.类.*，idea可以自动优化导入包,但是有多个同名的类调用不同的包,必须自己手动Alt+Enter设置 设置idea导入包 勾选标注 1 选项,IntelliJ IDEA 将在我们书写代码的时候自动帮我们优化导入的包,比如自动去掉一些没有用到的包. 勾选标注 2 选项,IntelliJ IDEA 将在我们书写代码的时候自动帮我们导入需要用到的包.但是对于那些同名的包,还是需要手动 Alt + Enter 进行导入的
泛型：1.class point<P R>;2.如果想要使用泛型，则能够采用的类型只能是类，即不能是基本数据类型，只能是引用数据类型



printstacktrace()所有的异常类都会有这个方法，利用这个方法可以输出异常信息，告诉用户是第几行出现了异常
throw表示的是代码抛出异常的可能性，实际上跑不抛出异常是由代码运行时决定的
当方法抛出异常后方法的调用会有变化吗？会有变化，因为方法的调用者会接受这个异常，这是一个编译时异常，需要在编译时显式处理它，如果main方法中
面试题：请解释error和异常的区别：error指的是JVM错误，这时程序并没有执行，无法处理；exception：指的是程序运行时产生的异常，用户可以用异常处理格式进行处理
为什么不使用throwable来处理异常：使用throwable来进行处理在运行时不会产生错误但是会产生逻辑错误，因为throwable的范围要比exception的范围大，如果用throwable处理不仅会处理exception还会处理error，所以在开发中需要处理异常时还是以exception为主。
异常时一起处理好还是分开处理好？在实际的开发过程中需要根据实际情况来进行相关的处理如果开发环境严谨，基本上要求针对每一种异常进行分开处理，并且需要详细记录下异常产生的时间以及产生的位置，方便程序维护人员进行代码的维护
面试题：简述throw和throws的区别：throw指的是在方法中人为抛出一个异常类对象（这个异常类对象可能是自己的实例化或者是抛出已存在的）；throws在方法的声明上使用表示此方法调用时必须处理异常
runtimeexcept和except的关系：父子类，except中定义了必须处理的异常，而runtimeexcept定义的异常可以选择性的进行处理，常见的runtimeexcept有：numberformat....\classcast...\nullpointer...\arithmetic....\arrayindex....\arrayindex....\
assert关键字进行断言操作：一定要在运行时增加-ea选项




6月26日
如果不设置泛型会怎样？为了保证设计的合理性如果不设置泛型会使用object类型，在进行数据取出时，必须强制类型转换，但这样会有安全隐患，由于没有使用正确的泛型类，在编译时会出现警告信息point<integer>p = new point<>();这只在声明中使用了反省，而在实例化中并没有设置具体的泛型类型，可以达到简化代码的目的，
通配符：为了解决泛型类型不同而导致的不能直接进行引用操作的问题，例如：message<string> m=new message<string>();表示泛型是string的message对象就接受而不能接收非string的message对象，使用通配符后》fun(message<?> temp)表示只要是message对象不管是何种类型的fun()方法都可以进行接收
通配符的子通配符：？ extends 类 ：设置泛型上线，可以再声明和方法参数上使用，意味着可以设置父类或者是父类的所有子类；？super 类：设置泛型下限，表示只能设置父类父类以上的类
泛型接口的两种实现形式：1.在子类继续设置泛型标记；2.在子类不设置泛型，而为父类明确定义一个泛型类型。泛型定义方法：可以在方法的返回值或参数类型上使用泛型标记进行声明
枚举：需要定义枚举类enum color{枚举的内容}调用方式为color red=color.getinstance(1);
关于enum类中提供的构造方法：枚举是一种简化的多例模式，而多例模式的关键部分就是构造方法私有化，但enum类设计时考虑到继承与子类实例化调用构造的因素，所以构造方法上使用类protected权限定义，这也表示一种封装；
枚举在使用中的两点需要注意的问题：1.枚举中定义的构造方法不能使用public声明，如果没有无参构造，要手工调用构造传递参数，枚举对象需要放在首行，随后才可以定义属性，构造方法和普通方法等结构，
Annotation：《名师讲坛——Java开发实战经典》中有详细的介绍，正是因为annotation的广泛使用，所以在JPA标准、spring开发框架和HTML 5 等技术使用环境中，才不会让开发者更多的受限于方法名称的困境中，Javase中提供了三中最为常见的Annotation定义，分别是：@override，@deprecated,@suppresswarnings
准确地覆写@override；
声明过期操作：@deprecated;
压制警告：@suppresswarnings；开发者已经明确知道这些警告信息，并执意按照固定方式进行处理，使用@suppresswarnings可以压制所有出现的警告信息；
关于@functionalinterface注解的使用，lambda表达式明确要求是在接口上进行一种操作，并且接口中只允许定义一种抽象方法，但是在一个项目中往往会定义大量的接口，而为了分辨出lambda表达式的使用接口，可以在接口上使用@functionalInterface注解声明，这样就表示此为函数式接口，里面只允许定义一个抽象方法。不过从理论上来讲只有一个抽象方法写不写@functionInterface是没有区别的，但是为了标准化尽量加上；
方法的引用的4中操作形式：引用静态方法：类名称：：static 方法名称；引用某个对象的方法：实例化对象：：普通方法；引用特定类型的方法：特定类：：普通方法；引用构造方法：类名称：：new;
内建函数式接口：对于可能出现的函数式接口的方法最多只有四类：有参数有返回值；有参数无返回值；无参数有返回值；判断真假；因此在Java中提供了以下4个核心的函数式接口：1.功能性接口@interfaceinterface public interfaceface function<T,R>{public R apply(T t);}这个接口需要接收一个参数，并返回处理结果；2.消费性接口：@functioninterface public interface consumer<T>{public void accept<T>{public void accept(T t)}此接口只适用于接收数据但并不会返回处理结果；3.供给型接口：@functioninterface public interface supplier<T>{public T get();}主要作用：不接受数据但是可以返回结果；4.断言型接口：@functionalInterface public interface predicate<T>{public boolean test(T t);}





6月29日
打印流的四个特点：1.只能操作目的地，不能操作数据来源：没有响应的输入流与之对应；2.可以操作任意的数据类型：把不同的数据类型转换成了字符串；如果启动了帅新功能就能自动刷新只有printf，println，format才会自动刷新；4.能够操作文件的流，穿的惨数可以是文件对象或者是文件名
system。out的本质是字节打印流；system.in的本质是一个普通的字节输入流
要想水仙序列化功能必须要实现serlizerable接口serlizerable接口是以个空接口哦起到标记的作用

csublime
如果类中的成员变量信息不想被序列化使用关键字transient

7月8日
面试题：解释comparable和comparator的区别：1.如果对象数组要进行排序就必须设置排序规则，可以使用comparable或者是comparator来接口来实现，comparable是一个类定义实现好的接口，这样本类的对象数组就可以尽心排序，在comparable下定义了public int comparato（）方法；comparator是一个专门定义指定类的比较规则属于挽救的比较操作里面有两个方法：public int compare（）、public boolean equals（）