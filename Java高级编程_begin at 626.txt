6月26日
线程与进程的历史关系：早期的单线程有一个最大的特征就是同一个时间只能有一个程序执行，一旦计算机出现病毒就会立即死机；后来有了多进程，即使计算机侵入了非致命的病毒也可以正常的使用，但是计算机资源还是只有一块，所以虽然说是多个程序共同执行但是在一个时间点上仍然是只有一个程序在执行，多线程实在一个进程的基础上进行进一步的划分，保证了性能得到了显著提高；
多线程的实现：多线程的实现依赖线程主体类，在主体定义时需要继承thread类或者实现runnable来完成定义；，但是使用callable更加合理一些，因为使用thread类的实现方式会带来单继承的局限；
为什么多线程的启动不是调用run()而必须调用start()?多线程的启动必须要操作系统的支持，直接调用run（）并不报错，但这时就变成了调用普通方法，不属于线程，可以通过查看start的源代码查看的到
start 中调用了系统的start0（）方法，这时一个JVM的本地方法，采用了JNI技术，这门技术的特点是使用Java调用本机操作系统提供的函数，但这个技术有一个缺点就是不能离开特定的操作系统，如果想要执行线程，需要操作系统进行资源分配，所以此操作严格来讲是由JVM根据不同的操作系统来实现的，即使使用thread类的start（）方法不仅要启动多线程的执行代码，还要根据不同的操作系统进行资源的分配。如果某一个线程对象进行了启动（同一个线程对象调用多次start0方法），就会抛出异常
runable中没有start（）怎么启动多线程：此时可以看到thread类中提供的有参构造方法：public thread（runable target），本方法可以用来杀接收一个runnable的接口类对象；
thread和runnable的练习与区别：为了解释这种练习可以查看thread类的源码中可以看出public classthread extends object implemens runnable；这样对于之前可以利用runnable接口来是吸纳多线程，这种代码模式类十余代理设计模式，但是并不是严格意义上的代理设计模式，因为严格意义上来讲的代理设计模式中，代理追能够使用的方法依然是接口中定义的run（）方法，而此处的代理涉及被漠视中主体所调用的是start（）方法，所以只能说形式上类似于代理设计模式，但本质上仍有差别；除了这点意外，对于runnable和thread类来说还有一个不太好区分的特点，就是runnable接口可以更加方便的表现出数据共享的概念；
面试题：请解释多线程的两种实现方式及区别，分别编写程序验证两种实现方式：多线程的两种实现方式都需要一个线程的主类，而这个类可以实现runnable接口或者是继承thread类，不管是 使用何种方式都需要重写run（）方法，此方法为线程的主方法；2.thread类是runnable接口的子类，而且使用runable接口可以避免单继承的局限，而且可以更加方便的实现数据共享的概念。
callable方法可以用来实现多线程：从jdk1.5开始，Java对于多线程的实现提供了一个新的接口：Java.util.concurrent.callable;本接口中存在一个call（）方法，而在call（）方法上可以实现线程操作的数据返回，返回的数据类型callable接口的泛型类型是动态决定的；并可以通过funturetask类继承结构可以发现他是runnable接口的子类，并且funturetask类可以接受callable接口实例，这样依然可以利用thread类来实现多线程的启动，如果想接收返回结果利用furure接口中的get（）方法即可；
多线程常用的操作方法：1.线程的命名与取得：由于多线程的状态的不确定，所以每次都可以操作的都是正在执行的run()方法的线程，那么取得当前线程对象的方法为：public static thread current thread
进程在哪里？每一个JVM运行就是进程：当用户使用Java命令执行一个类时就表示启动了一个JVM进程，而主方法只是这个进程上的一个线程而已，当一个类执行完毕后，进程就会自动消失，而且每一个JVM进程都至少启动以下两个线程：main线程和gc线程
线程的休眠sleep（）；
设置线程的优先级：

关于子线程：在程序开发中，所有程序都是通过主方法执行的，而主方法本身就属于一个主线程，所以通过主方法创建的新的线程对象都是子线程，在Android开发中默认运行的Activity就可以理解为主线程，当移动设备需要读取网络信息时往往会启动新的子线程读取，而不会在主线程中操作。利用子线程可以进行一步的操作处理，这样可以在不影响主线程运行的前提下进行其他操作，程序的执行速度不仅变快了，并且操作起来也不会产生太多的延迟。
Java中有4种代码块：普通代码块，构造块，静态块，同步块 
Java中要实现线程同步，需要使用synchronize关键字包装同步代码块有两种方法：同步代码块：利用synchronized包装的代码块，但是需要指定要同步的对子昂，一般设置成this；同步方法：利用synchronized定义的方法
面试题：同步和异步有什么区别：如果一整块数据要在多个线程间进行共享，例如，正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须要进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率
面试题：abstract的方法是否可以同时是static，是否可以是native，是否可以是synchronized:method ,static,native,synchronized?:method,static ,native,synchronized 都不能和abstract同时声明方法；
面试题：当一个线程进入一个对象synchronized方法后，其他线程是否可以访问此对象的其他方法：不能访问，一个对象操作一个synchronized方法只能有一个多线程访问；
面试题：请解释当个线程访问同一个资源时需要考虑那些情况？有可能带来那些问题？：多个线程访问同一个资源时，考虑到数据操作的安全性问题，一定要使用同步操作，具有以下两种操作模式：同步代码块：synchronized(锁定对象){代码}；2.同步方法：public synchronized 返回值 方法名称（）{代码}。过多的同步操作有可能会带来死锁问题，导致程序进入停滞状态；
解决数据错乱问题：数据错乱问题是因为非同步的操作导致的，所以应该是用同步处理，因为取出和设置是两个不同的操作，所以要进行同步控制，就需要将其定义到一个类里面；
解决数据重复问题：要想解决数据重复问题，需要等待及唤醒机制，而这一机制只能依靠object类来完成，在object类找那个定义了3个方法完成线程的操作：public final void wait() throws interruptedexception(线程的等待)；public final void notify() (唤醒第一个线程的等待)；public final void notifyAll（）唤醒全部等待进程；
面试题：解释sleep和wait的区别：sleep()是thread类定义的static方法，表示线程休眠，将执行机会给其他线程，但是监控状态依然保持，会自动恢复；wait()是object类定义的方法，表示线程等待，一直执行了notity()或者notityAll()后才会结束等待。
线程的声明周期：3个新的方法：suspend()暂时挂起线程；resume() 回复挂起的线程；stop()停止线程，这三个问题用来解决操作时产生的死锁问题；


stringbuffer
通过string和stringbuffer两个类的定义结构可以看出，string和stringbuffer类都是charsequence接口的子类，也就可以证明string或者stringbuffer类的对象都可以使用自动向上转型的操作为charsequence接口实例化；例如string类的实例化对象可以向上转型为charsequence接口对象，同样也可以利用插入dequence接口接收stringbuffer类对象。
在一些类库中出现接收charsequence接口对象的方法，简单的话只需要传递字符串即可操作。但需要注意的是，在charsequence接口里面提供的charat(),length()方法；
string和stringbuffer不能直接进行转换，这两个类之间转换的原则是：原则一：将string转换为stringbuffer类对象。方式一：利用stringbeffer类的构造方法，在stringbuffer类中提供一个专门的接收string类随想的构造方法，利用此构造方法可以将传递进的string类对象实例化stringbuffer对象；方式二：利用stringbuffer类中的append方法项stringbuffer类对象中增加一个string类对象，这样就相当于将string类对象编程一个stringbuffer类对象；
将stringbuffer转换为string类对象：方式1.利用tostring（）可以将stringbuffer转换为string，实际上所有的类中都会继承object类中的tostring方法看，所以所有的类对象都可以转换为string类对象；方式2.利用string类对象的构造方法事项stringbuffer与string类对象之间的转化
string类对象和stringbuffer对象的比较：由于string和stringbuffer类都乐意表示字符串，所以在多态ring类里面也提供了一个和stringbuffer比较的方法a:public boolean contentequals（stringbuffer sb）
stringbuffer中常用的操作方法：publicstringbuffer append（数据或者变量）表示数据的追加操作；public stringbuffer reverse（）用于字符串的反转操作；public stringbuffer insert（intoffset，住居类型 变量）用于在指定位置后面追加内容；public stringbuffer delete（intstart ，intend）删除指定范围内的内容；
面试题：解释string类stringbuffer和stringbuilder类三者之间的区别：string类内容一旦声明就不可变，而stringbuffer类与stringbuilder类生命的内容可以改变；stringbuilder类中提供的房还是发都是同步方法，属于安全的线程操作；而stringbuilder类中的方法啊都属于异步方法，属于非线程安全的操作；

runtime类：用于获得当前JVM系统的各个内存空间信息，runtime类使用了单例设计模式；一个类中至少会存在一个构造方法，如果本类中没有定义任何一个构造方法，那么会自动生成一个无参的构造方法。但是访用户发开runtime是会发现一个问题在这个类当中并没有定义说明，可是这个类的构造党发确实真实存在的，因为在声明中对构造方法进行了封装，所以runtime类是以个典型的单例设计模式，单例设计模式所属的类一定会提供一个static的方法吗，用于取得本类中的实例化对象，取得本利的实例化对象，所以在runtime类中也提供一个getruntime() 方法用于取得本类实例化对象，取得runtime类的实例化对象的行为为：public static runtime getruntime（）
runtime类的常用方法：public static runtime（）用于取得runtime类的实例化大小；public longma小memory用于返回最大的内存大小；public long totalmemory 用于返回所有可用内存的大小；public longfreememory返回所有空余内存的大小；public voidgc（）执行垃圾回收操作；public process exec(string command) throws IOexception 创建新的进程
设计解决方案调整JVM 的内存空间：每一块内存空间都会有一个内存收缩去，当内存空间不足时就会动态进行开辟，所以为了提高性能，在实际应用中可能开辟尽量大的一些内存空间，可以使用如下参数。“-xms”初始分配内存，默认大小是一个1/64物理内存的大小但是会小于1G，“xmx最大分配内存”默认大小时1/4物理内存大小，但小于1G；“-xmn”设置年轻代对内存的大小；
垃圾回收处理与对象的创建：虽然垃圾手机处理只通过一个gc()方法可以实现，但是垃圾回收与Java的内存空间划分是有关系的：对于GC的执行可以描述为当JVM剩余空间不足时就会触发gc，如果Eden内存空间不足就要进行从回收，旧生代空间不足时要进行主回收，永久空间内存不足时会进行完整的垃圾回收
gc进行垃圾回收的流程：（1）当使用new关键字创建一个新的对象时，JVM就会将新建的对象保存在Eden区。但是此时需要判断Eden区是否有剩余的空间，如果有，则直接将新对象保存在Eden区内，如果没有，则会执行minor gc(年轻代gc)2.再执行玩minorgc后悔清除掉，不活跃的对象，从而释放出Eden区的内存空间，随后会对Eden空间进行在此判断，如果此时剩余空间可以容纳新对象，则会再接为新对象申请内存空间，如果此时Eden区的空间依然不足，则会将部分活跃对象保存到survivor区；3.由于survivor区也有对象会粗出在内，所以在保存Eden区发送来的对象前首先先要判断空间是否充足如果survivor有足够的空余空间，则直接保存Eden区晋升的对象，那么此时Eden区将得到空间的释放，随后可以再Eden区为新的对象申请内存空间的额开辟；如果survovor区空间不足，就需要survivor区中不活跃的对象保存到tenured区；）（4）tenured区如果有足够的内存空间，则会将survivor区发送来的对象进行保存，如果此时tenured区的内存空间也已经满了。则将执行fullgc,包括年轻代和老年代，相当于使用“runtime。getruntime（）。gc()”



7月1日：
线程中的start方法和run方法的区别和联系：使用run方法只是调用了 一个普通的方法，并没有启动另一个线程，程序还是会按照顺序执行相应的代码；start（）方法开启了一个县城不必等其他线程运行完，只要得到CPU资源就可以运行该线程，run方法是Java虚拟机直接调用的，如果没有启动线程而是应用代码中直接调用run方法那么这个方法其实运行在当前的线程之中，而不知运行在其自身的线程之中，从而违背了创建线程的初衷，只有通过调用start（）方法才能够真正的达到多线程的目的，如果直接调用的run方法，就是当做是普通的函数调用，程序中仍然有这一个线程，也就是说，start方法能够异步的调用run方法，但直接调用run方法是同步的，因此也就无法达到真正的多线程的目的；
线程的两种调度方法：1.协同式调度方法：（线程将自己的工作执行完成后就主动切换到另一个线程上，非常简单不用考虑线程同步的问题，但是倘若某一个线程编写有问题，就一直不告知系统进行线程切换，程序就会一直阻塞在原地）线程的执行时间有线程本身决定，当该线程完成了自己的工作回想系统报告切换了另外一个线程，实现方式简单，缺点是线程执行期间不可控；2.抢占式调度：线程的执行时间由系统决定，不由线程本身决定，线程的执行时间可控； 
Java中的优先级不怎么起作用，Java中执行的是静态优先级，而系统执行取决于动态优先级和静态优先级的和；
线程的常用的API：sleep：			；2.线程等待：join：谁等待：主线程在等待，join这个代码在哪个线程上执行，那个线程就等待；等待谁：等待的子线程，等待的就是调用了join的这个线程；礼让线程 ：yield你拍一我拍一这种玩儿法：执行yield方法，暂停当前正在执行的线程对象，并执行其他线程；守护进程：程序运行的过程中在后台提供的一种通用服务的线程，比如垃圾回收之类的；用户进程和守护进程之间几乎没有区别，唯一的不同就是在虚拟机离开的时候如果用户线程已经全部退出云慈宁宫了只剩下守护进程存在，虚拟机也就推出了，因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了；

作业中遇到的一个异常：没有将wait和notify写进synchronized中：原因：wait是一个底层方法，底层是通过一个叫做监视器锁的对象来完成的，所以之所以会抛出异常，是因为在调用wait方式时，没有通过monitor的所有权，而在Java中只能通过synchronized关键字来获得monitor对象的所有权，所以wait方法必须在同步的范围内，wait的方法的作用是通过阻塞当前的进程等待notify方法进行唤醒，或者等待超时后就会自动唤醒；
sleep和wait的方法的区别，最简单的区别就是wait方法依赖于同步，而sleep方法可以进行直接调用，而深层次的理解是sleep方法只是暂时让出CPU的执行权并不释放锁，而wait方法必须要释放锁，sleep暂停期间一直持有monitor对象锁，其他进程是不能进入的，而wait方法不同，调用wait方法后，当前线程会释放掉持有的monitor对象锁，因此其他线程可以进入到同步方法，线程被唤醒后需要竞争锁，或得到锁之后在继续执行；
关于yield方法可能没有作用的是哪个解释：调度器可能会忽略该方法，使用的时候要仔细地进行测试和分析，确保能够达到预期的效果，在很少的场景会用到该方法，主要使用的地方其实是调试和测试；



向线程池提交任务有两种方式：1.实现runable接口；//future《？》submit(runable task)提交一个任务（命令中的future表示异步运行的计算结果），
怎么关闭线程池：shutdown和shutdownnow方法，shutdown启动一次关闭，执行以前提交的任务，但不接受新任务，即队列中的其他进程也可以执行；shutdownnow方法会立即关掉正在执行的进程和阻塞队列列线程，并返回等待执行的任务列表；
future表示意不计算的结果。它提供了检查计算是否完成的方法，一等待计算的完成，并获取计算的结果，计算完成后只能使用get方法来获取结果，如果有必要计算完成可以阻塞此方法
future和get() 方法的区别：get()如果有必要，等待计算的完成然后获取其结果


callable和runable，runable方法没有返回值，callable方法有返回值；runable中实现的是常规的run方法，callable中实现的是call方法；

定时器和 定时任务：任务用小顶堆这种数据结构，按照定时任务将要执行色顺序队列；构造方法：timer（）创建一个新的计时器；timer(boolean isDeamon)创建一个新计时器可以指定其相关的线程作为守护进程运行；

常见面试题：array好arrrylist有什么区别：array的数组的内容是固定的，而ArrayList中保存的是可变的，在很多时候数组列表进行数据保存时需要一系列的判断，而数组只需要索引判断即可；在已经确定好长度的前提下，完全可以使用数组来代替数组列表，但是如果数组的内容长度是不固定的，那么适合使用数组列表；3，很多开发框架会将数组与list集合作为同一种形式，
vector和ArrayList的区别： 同步性:Vector是线程安全的，也就是说是同步的 ，而ArrayList 是线程序不安全的，不是同步的 ；数据增长:当需要增长时,Vector默认增长为原来一倍 ，而ArrayList却是原来的50%  ，这样,ArrayList就有利于节约内存空间；如果涉及到堆栈，队列等操作，应该考虑用Vector，如果需要快速随机访问元素，应该使用ArrayList 。
hashtable和hashmap的区别：Hashtable和HashMap它们的性能方面的比较类似 Vector和ArrayList，比如Hashtable的方法是同步的,而HashMap的不是。
ArrayList和LinkedList 的区别：ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间，所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能； 而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止，所以,当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了
map和collection的区别：
collection和collections的区别：
mapreduce


